package main

import (
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"

	"gorm.io/gen"
)

// TestPostgresDbInitTemplateNoDB validates the Postgres DbInit code generation
// without connecting to any Postgres server by fabricating a generator with
// fake model names and invoking generatePostgresDbInit directly.
func TestPostgresDbInitTemplateNoDB(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping postgres template test in short mode")
	}

	// Create an OutPath under the project root so that package name resolution is simple.
	outPath := filepath.Join(projectRootPG(t), "generated_pg_nodb")
	if err := os.MkdirAll(outPath, 0o755); err != nil {
		t.Fatal(err)
	}
	t.Cleanup(func() { _ = os.RemoveAll(outPath) })

	// Create a minimal gen.Generator and populate its Data map with fake model names.
	g := gen.NewGenerator(gen.Config{
		OutPath:      outPath,
		ModelPkgPath: filepath.Join(outPath, "models"),
	})
	// NewGenerator already initializes g.Data (map[string]*genInfo). We only need keys; values can be nil.
	g.Data["Foo"] = nil
	g.Data["Bar"] = nil

	// Prepare a minimal Postgres config with IncludeAutoMigrate enabled.
	cfg := ConversionConfig{
		IncludeAutoMigrate: true,
		DbHost:             "db.example.local",
		DbPort:             5432,
		DbName:             "unit_test_db",
		DbUser:             "test_user",
		DbPassword:         "secret",
		DbSSLMode:          false,
	}

	// Generate the db.go initializer using the template function.
	generatePostgresDbInit(cfg, g)

	// Verify the output file was created.
	outFile := filepath.Join(outPath, "db.go")
	b, err := os.ReadFile(outFile)
	if err != nil {
		t.Fatalf("reading generated db.go: %v", err)
	}
	content := string(b)

	pkgBase := filepath.Base(outPath)

	// Assertions on generated content.
	mustContain(t, content, "Code generated by gormdb2struct; DO NOT EDIT.")
	mustContain(t, content, "package "+pkgBase)
	mustContain(t, content, "\""+pkgBase+"/models\"")
	// Ensure AutoMigrate contains our fake models
	mustContain(t, content, "&models.Foo{}")
	mustContain(t, content, "&models.Bar{}")
	// Ensure DSN is constructed via utilities when optional DSN is not provided
	mustContain(t, content, "utilities.DbDSN(")
}

func mustContain(t *testing.T, s, sub string) {
	t.Helper()
	if !strings.Contains(s, sub) {
		t.Fatalf("expected generated content to contain %q, but it did not", sub)
	}
}

// projectRootPG returns the repo root directory (same strategy as the SQLite test)
func projectRootPG(t *testing.T) string {
	_, file, _, _ := runtime.Caller(0)
	return filepath.Dir(file)
}
